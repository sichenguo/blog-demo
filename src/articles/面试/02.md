# JS 基础知识点及常考面试题（一）

JS 对于每位前端开发都是必备技能，在小册中我们也会有多个章节去讲述这部分的知识。首先我们先来熟悉下 JS 的一些常考和容易混乱的基础知识点。

## 原始（Primitive）类型

> 涉及面试题：原始类型有哪几种？null 是对象嘛？

在 JS 中，存在着 6 种原始值，分别是：

- `boolean`
- `null`
- `undefined`
- `number`
- `string`
- `symbol`

首先原始类型存储的都是值，是没有函数可以调用的，比如 `undefined.toString()`



![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="526" height="53"></svg>)



此时你肯定会有疑问，这不对呀，明明 `'1'.toString()` 是可以使用的。其实在这种情况下，`'1'` 已经不是原始类型了，而是被强制转换成了 `String` 类型也就是对象类型，所以可以调用 `toString` 函数。

除了会在必要的情况下强转类型以外，原始类型还有一些坑。

其中 JS 的 `number` 类型是浮点类型的，在使用中会遇到某些 Bug，比如 `0.1 + 0.2 !== 0.3`，但是这一块的内容会在进阶部分讲到。`string` 类型是不可变的，无论你在 `string` 类型上调用何种方法，都不会对值有改变。

另外对于 `null` 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 `typeof null` 会输出 `object`，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，`000` 开头代表是对象，然而 `null` 表示为全零，所以将它错误的判断为 `object` 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

## 对象（Object）类型

> 涉及面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？

在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。

```
const a = []
```

对于常量 `a` 来说，假设内存地址（指针）为 `#001`，那么在地址 `#001` 的位置存放了值 `[]`，常量 `a` 存放了地址（指针） `#001`，再看以下代码

```
const a = []
const b = a
b.push(1)
```

当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量 `b` 存放的地址（指针）也是 `#001`，当我们进行数据修改的时候，就会修改存放在地址（指针） `#001` 上的值，也就导致了两个变量的值都发生了改变。

接下来我们来看函数参数是对象的情况

```
function test(person) {
  person.age = 26
  person = {
    name: 'yyy',
    age: 30
  }

  return person
}
const p1 = {
  name: 'yck',
  age: 25
}
const p2 = test(p1)
console.log(p1) // -> ?
console.log(p2) // -> ?
```

对于以上代码，你是否能正确的写出结果呢？接下来让我为了解析一番：

- 首先，函数传参是传递对象指针的副本
- 到函数内部修改参数的属性这步，我相信大家都知道，当前 `p1` 的值也被修改了
- 但是当我们重新为了 `person` 分配了一个对象时就出现了分歧，请看下图

![img](https://user-gold-cdn.xitu.io/2018/11/14/16712ce155afef8c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





所以最后 `person` 拥有了一个新的地址（指针），也就和 `p1` 没有任何关系了，导致了最终两个变量的值是不相同的。

## typeof vs instanceof

> 涉及面试题：typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？

`typeof` 对于原始类型来说，除了 `null` 都可以显示正确的类型

```
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
```

`typeof` 对于对象来说，除了函数都会显示 `object`，所以说 `typeof` 并不能准确判断变量到底是什么类型

```
typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'
```

如果我们想判断一个对象的正确类型，这时候可以考虑使用 `instanceof`，因为内部机制是通过原型链来判断的，在后面的章节中我们也会自己去实现一个 `instanceof`。

```
const Person = function() {}
const p1 = new Person()
p1 instanceof Person // true

var str = 'hello world'
str instanceof String // false

var str1 = new String('hello world')
str1 instanceof String // true
```

对于原始类型来说，你想直接通过 `instanceof` 来判断类型是不行的，当然我们还是有办法让 `instanceof` 判断原始类型的

```
class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === 'string'
  }
}
console.log('hello world' instanceof PrimitiveString) // true
```

你可能不知道 `Symbol.hasInstance` 是什么东西，其实就是一个能让我们自定义 `instanceof` 行为的东西，以上代码等同于 `typeof 'hello world' === 'string'`，所以结果自然是 `true` 了。这其实也侧面反映了一个问题， `instanceof` 也不是百分之百可信的。

## 类型转换

> 涉及面试题：该知识点常在笔试题中见到，熟悉了转换规则就不惧怕此类题目了。

首先我们要知道，在 JS 中类型转换只有三种情况，分别是：

- 转换为布尔值
- 转换为数字
- 转换为字符串

我们先来看一个类型转换表格，然后再进入正题



![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="910" height="648"></svg>)



### 转Boolean

在条件判断时，除了 `undefined`， `null`， `false`， `NaN`， `''`， `0`， `-0`，其他所有值都转为 `true`，包括所有对象。

### 对象转原始类型

对象在转换类型的时候，会调用内置的 `[[ToPrimitive]]` 函数，对于该函数来说，算法逻辑一般来说如下：

- 如果已经是原始类型了，那就不需要转换了
- 调用 `x.valueOf()`，如果转换为基础类型，就返回转换的值
- 调用 `x.toString()`，如果转换为基础类型，就返回转换的值
- 如果都没有返回原始类型，就会报错

当然你也可以重写 `Symbol.toPrimitive` ，该方法在转原始类型时调用优先级最高。

```
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  },
  [Symbol.toPrimitive]() {
    return 2
  }
}
1 + a // => 3
```

### 四则运算符

加法运算符不同于其他几个运算符，它有以下几个特点：

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```
1 + '1' // '11'
true + true // 2
4 + [1,2,3] // "41,2,3"
```

如果你对于答案有疑问的话，请看解析：

- 对于第一行代码来说，触发特点一，所以将数字 `1` 转换为字符串，得到结果 `'11'`
- 对于第二行代码来说，触发特点二，所以将 `true` 转为数字 `1`
- 对于第三行代码来说，触发特点二，所以将数组通过 `toString` 转为字符串 `1,2,3`，得到结果 `41,2,3`

另外对于加法还需要注意这个表达式 `'a' + + 'b'`

```
'a' + + 'b' // -> "aNaN"
```

因为 `+ 'b'` 等于 `NaN`，所以结果为 `"aNaN"`，你可能也会在一些代码中看到过 `+ '1'` 的形式来快速获取 `number` 类型。

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字

```
4 * '3' // 12
4 * [] // 0
4 * [1, 2] // NaN
```

### 比较运算符

1. 如果是对象，就通过 `toPrimitive` 转换对象
2. 如果是字符串，就通过 `unicode` 字符索引来比较

```
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  }
}
a > -1 // true
```

在以上代码中，因为 `a` 是对象，所以会通过 `valueOf` 转换为原始类型再比较值。

## this

> 涉及面试题：如何正确判断 this？箭头函数的 this 是什么？

`this` 是很多人会混淆的概念，但是其实它一点都不难，只是网上很多文章把简单的东西说复杂了。在这一小节中，你一定会彻底明白 `this` 这个概念的。

我们先来看几个函数调用的场景

```
function foo() {
  console.log(this.a)
}
var a = 1
foo()

const obj = {
  a: 2,
  foo: foo
}
obj.foo()

const c = new foo()
```

接下来我们一个个分析上面几个场景

- 对于直接调用 `foo` 来说，不管 `foo` 函数被放在了什么地方，`this` 一定是 `window`
- 对于 `obj.foo()` 来说，我们只需要记住，谁调用了函数，谁就是 `this`，所以在这个场景下 `foo` 函数中的 `this` 就是 `obj` 对象
- 对于 `new` 的方式来说，`this` 被永远绑定在了 `c` 上面，不会被任何方式改变 `this`

说完了以上几种情况，其实很多代码中的 `this` 应该就没什么问题了，下面让我们看看箭头函数中的 `this`

```
function a() {
  return () => {
    return () => {
      console.log(this)
    }
  }
}
console.log(a()()())
```

首先箭头函数其实是没有 `this` 的，箭头函数中的 `this` 只取决包裹箭头函数的第一个普通函数的 `this`。在这个例子中，因为包裹箭头函数的第一个普通函数是 `a`，所以此时的 `this` 是 `window`。另外对箭头函数使用 `bind` 这类函数是无效的。

最后种情况也就是 `bind` 这些改变上下文的 API 了，对于这些函数来说，`this` 取决于第一个参数，如果第一个参数为空，那么就是 `window`。

那么说到 `bind`，不知道大家是否考虑过，如果对一个函数进行多次 `bind`，那么上下文会是什么呢？

```
let a = {}
let fn = function () { console.log(this) }
fn.bind().bind(a)() // => ?
```

如果你认为输出结果是 `a`，那么你就错了，其实我们可以把上述代码转换成另一种形式

```
// fn.bind().bind(a) 等于
let fn2 = function fn1() {
  return function() {
    return fn.apply()
  }.apply(a)
}
fn2()
```

可以从上述代码中发现，不管我们给函数 `bind` 几次，`fn` 中的 `this` 永远由第一次 `bind` 决定，所以结果永远是 `window`。

```
let a = { name: 'yck' }
function foo() {
  console.log(this.name)
}
foo.bind(a)() // => 'yck'
```

以上就是 `this` 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 `this` 最终指向哪里。

首先，`new` 的方式优先级最高，接下来是 `bind` 这些函数，然后是 `obj.foo()` 这种调用方式，最后是 `foo` 这种调用方式，同时，箭头函数的 `this` 一旦被绑定，就不会再被任何方式所改变。

如果你还是觉得有点绕，那么就看以下的这张流程图吧，图中的流程只针对于单个规则。



![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="744" height="531"></svg>)



## 小结

以上就是我们 JS 基础知识点的第一部分内容了。这一小节中涉及到的知识点在我们日常的开发中经常可以看到，并且很多容易出现的坑 也出自于这些知识点，相信认真读完的你一定会在日后的开发中少踩很多坑。如果大家对于这个章节的内容存在疑问，欢迎在评论区与我互动。

留言



- 

  [王亮亮](https://juejin.im/user/5b40d391f265da0fa009fb5f)

  前端开发 @ e修鸽

  老师你好，foo.bind(a)() 与 foo.call(a);这两个表达式是一样的吗？为什么bind()后面还需要加一个（）

  收起评论



  4天前

  - 

    [舜叔](https://juejin.im/user/5a02cb83f265da43333dd50e)



    bind会返会一个改变了this指向的函数，call是直接返回执行后的结果，所以foo.bind(a)后面要加一个()来调用

    3天前

  - 

    [我是一个前端](https://juejin.im/user/5798222e6be3ff00662edf6b)

    前端开发

    bind返回的是一个函数 所以需要（）执行

    3天前

  - 

    [stone_](https://juejin.im/user/57ecb156a0bb9f0058e68b62)

    前端工程师

    bind(a)是返回一个新函数，并且内部this的指向是这个a

    3天前

  评论

- 

  [cg1](https://juejin.im/user/5c233fb1e51d4534402a272e)



  比较运算符中，如果是对象会引用valueof() 变成基本数据类型。 const a = {   valueof(){ return 0 },   toString(){ return 2 } } a > 1  // 结果是true a < 1  // 结果是false，因为对象引用的是toString(), 好像不是valueof()？

  收起评论



  5天前

  - 

    [krysliang](https://juejin.im/user/5c032d2ee51d45195061f259)

    前端工程师 @ 惠州哈密

    先调用valueod(),返回0后再调用toString转化为字符串，此时返回2.

    3天前

  评论

- 

  [Robert ²⁰¹⁷](https://juejin.im/user/5a151cdf5188252ae93a96dc)

  前端工程师

  其中 JS 的 number 类型是浮点类型的。。。 这句没错吗？

  收起评论



  6天前

  - 

    [过河卒G](https://juejin.im/user/5ad1ecf0518825558a070cfb)

    前端工程师

    你再读几遍那段话，没问题的

    4天前

  评论

- 

  [阿仁在掘金](https://juejin.im/user/5bd272e4e51d457aa63a6f14)



  大佬，那个+ '1'获取number类型的是不是写错了，应该是＊ '1'吧

  收起评论



  7天前

  - 

    [yck](https://juejin.im/user/574f8d8d2e958a005fd4edac)

    前端开发 @ 宋小菜

    没有

    7天前

  - 

    [阿仁在掘金](https://juejin.im/user/5bd272e4e51d457aa63a6f14)



    回复[yck](https://juejin.im/user/574f8d8d2e958a005fd4edac)：我理解的快速获取number类型是指将 数字字符串 转为 number，那不应该用＊隐式转成number类型吗？还是我理解错了

    6天前

  - 

    [薛定谔的🐶、](https://juejin.im/user/5b28afea6fb9a00e4c4094b5)



    回复[yck](https://juejin.im/user/574f8d8d2e958a005fd4edac)：+也会隐式转成number

    6天前

  - 

    [大浪一歌](https://juejin.im/user/5aa1fd9851882510fd3f32e2)

    接盘侠 @ 深圳艾福彼爱区块链科技有限公司

    \+ '1'    的加号与字符串1之间是没有空格的

    6天前

  - 

    [墨空](https://juejin.im/user/57c51f2ea633bd005d8431a3)

    前端开发

    回复[yck](https://juejin.im/user/574f8d8d2e958a005fd4edac)：加号就有这个功能

    6天前

  - 1
  - 2
  - 下一页

  评论

- 

  [Farris](https://juejin.im/user/589ac1da8d6d81005859e946)

  前端工程师

  打卡

  1评论10天前

- 

  [法令男](https://juejin.im/user/5a9101d65188257a690f82c4)



  老师您好，有个地方不知道是不是我理解错了，您在类型转换表格里面提到“Boolean、函数、symbol”转换目标为字符串的时候，结果为‘true’，但我记得函数在转字符串的时候是返回整个函数的字符串类型，即： console.log(String(console.log)) // "function log() { [native code] }"

  收起评论



  10天前

  - 

    [yck](https://juejin.im/user/574f8d8d2e958a005fd4edac)

    前端开发 @ 宋小菜

    这边是我表达有问题了，这几个类型转为字符串就是在原本的代码变成字符串

    9天前

  - 

    [Swiftly](https://juejin.im/user/57f069b1a22b9d005bc0668a)

    iOS @ 好人生

    这点当时我也看懵了。

    5天前

  评论

- 

  [imeahu](https://juejin.im/user/5b0a26066fb9a07aa34ab6ff)

  前端工程师

  如果是字符串，就通过 unicode 字符索引来比较。  怎么比较的呢？

  收起评论



  11天前

  - 

    [yck](https://juejin.im/user/574f8d8d2e958a005fd4edac)

    前端开发 @ 宋小菜

    谷歌搜一下就行了

    9天前

  评论

- 

  [珈蓝白塔](https://juejin.im/user/58c02d400ce46300545589d3)



  连续 bind 那块儿完全没看懂啊～

  收起评论



  11天前

  - 

    [yck](https://juejin.im/user/574f8d8d2e958a005fd4edac)

    前端开发 @ 宋小菜

    那就多看几遍，我觉得已经讲得很清晰了

    9天前

  - 

    [薛定谔的🐶、](https://juejin.im/user/5b28afea6fb9a00e4c4094b5)



    bind后会返回一个新函数，所以后面的bind即使绑定新函数上而不是最初的函数

    6天前

  - 

    [珈蓝白塔](https://juejin.im/user/58c02d400ce46300545589d3)



    回复[yck](https://juejin.im/user/574f8d8d2e958a005fd4edac)：额。感谢老师回复。我知道 bind 会返回一个函数，但是我的疑惑是fn.bind().bind(a)()；先执行的是 fn.bind()哈，但是转化成普通函数却是最后才 return fn.apply()；为什么fn.bind()在最前面但却最后才 return 回了 fn.apply() 呢？难道是因为 bind 只是返回了函数，却没有调用，而 call 和 apply 是直接调用的原因？

    4天前

  - 

    [珈蓝白塔](https://juejin.im/user/58c02d400ce46300545589d3)



    回复[薛定谔的🐶、](https://juejin.im/user/5b28afea6fb9a00e4c4094b5)：emmmmm，我知道 bind 会返回一个函数，但是我的疑惑是fn.bind().bind(a)()；先执行的是 fn.bind()哈，但是转化成普通函数却是最后才 return fn.apply()；为什么fn.bind()在最前面但却最后才 return 回了 fn.apply() 呢？难道是因为 bind 只是返回了函数，却没有调用，而 call 和 apply 是直接调用的原因？

    4天前

  评论

- 

  [永孩儿](https://juejin.im/user/5712832f128fe1006cee5f3c)



  感受到了满满的干货，同时说明我基础薄弱，赞

  0评论11天前

- 

  [wq93](https://juejin.im/user/5adf202af265da0b84551306)

  前端工程师

  四则运算符 加法运算符不同于其他几个运算符，它有以下几个特点：  运算中其中一方为字符串，那么就会把另一方也转换为字符串 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串  "如果一方不是字符串或者数字，那么会将它转换为数字或者字符串 " 感觉这个总结的有问题,如果是引用类型的话应该是调用toPrimitive规则

  收起评论



  12天前

  - 

    [乔同志](https://juejin.im/user/5a8e531f51882524d842d0a8)



    我也是这样觉得

    11天前

  - 

    [Mr_big_shot_](https://juejin.im/user/582ebb53d20309006703a0c2)



    对的。

    10天前

  评论

- 

  [被清晨的馬路寵愛著](https://juejin.im/user/5b1108286fb9a01e3e5cdd62)

  前端实习生 @ 上海中期期货股份有限公司

  正在看

  0评论14天前

- 

  [枯木朽株](https://juejin.im/user/5bc3d8206fb9a05ce37b1fae)

  web前端 @ 杭州诚淘电商

  第一次比较全面的了解了this的指向问题

  0评论15天前

- 

  [AddOneG](https://juejin.im/user/5800c5b267f3560058a9f89f)

  前端 @ 小学二年级

  讲的一般

  7评论15天前

- 

  [YGL](https://juejin.im/user/592ff0572f301e006bcc313f)



  这个this图牛逼了

  2评论16天前

- 

  [sugusGeek](https://juejin.im/user/58edc26561ff4b00581ab586)

  web前端开发 @ 指点教育

  1.四则运算符的减法没有讲到哦，个加法还是不一样的，却更趋向于乘除法！2.隐式类型转换要是加入算式运算符和逻辑运算符后的混合运算，可以讲下哈！3.new Number 和 number , new String和string这种原始类型和对象类型的比较，哪些地方会用到，差异又在哪里！

  0评论16天前

- 

  [wscfan](https://juejin.im/user/5bd02abb5188252f4f600569)

  前端工程师

  跟着大佬走，没错。

  0评论17天前

- 

  [刘飞｜工作](https://juejin.im/user/5c2342a96fb9a04a04411142)



  [https://github.com/mqyqingfeng/Blog/issues/10](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F10)

  0评论17天前

- 

  [希望and现实](https://juejin.im/user/5bb6114cf265da0b001f459f)



  const p2 = test(p1)那边不就是返回preson嘛...没看出和指针有什么关系...还是我漏掉什么了

  收起评论



  18天前

  - 

    [wq93](https://juejin.im/user/5adf202af265da0b84551306)

    前端工程师

    person = {...}重新赋值了

    18天前

  - 

    [旅梦开发团](https://juejin.im/user/574d2f2a2e958a00693487b0)

    创始人 @ 旅梦开发团

    当p1传给test函数里面第一句代码就是利用了指针person和p1指向相同的地址，然后person再指向另外一个地址

    17天前

  - 

    [希望and现实](https://juejin.im/user/5bb6114cf265da0b001f459f)



    回复[旅梦开发团](https://juejin.im/user/574d2f2a2e958a00693487b0)：我指了解过一点点c，这里的意思是function里的指针是没有固定指向的嘛？

    17天前

  评论

- 

  [诺诺同志](https://juejin.im/user/5bd044496fb9a05d1658c8ea)



  确实牛批

  0评论19天前

- 

  [Rockj](https://juejin.im/user/5c1ed9216fb9a04a0f652ae5)

  前端工程师 @ 存勖科技

  好流弊啊

  0评论20天前

- 

  [汉景源](https://juejin.im/user/5b38b43ee51d45589d67f498)

  GIS/前端 @ 华南光电科技公司

  为什么true+true的结果是2，而不是'truetrue'呢？

  收起评论



  23天前

  - 

    [dsying](https://juejin.im/user/5b0e60f6f265da08f0339162)

    web @ 个体

    如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

    23天前

  - 

    [汉景源](https://juejin.im/user/5b38b43ee51d45589d67f498)

    GIS/前端 @ 华南光电科技公司

    回复[dsying](https://juejin.im/user/5b0e60f6f265da08f0339162)：这句话我又不是没看到。我认为这句话解释不了true+true为什么等于2。true+true等于2的解释应该使用的是当boolean类型相加时，true/false会向number转换进行计算。而当boolean与非boolean进行运算时，才应该触发特点二。

    22天前

  - 

    [太微天帝](https://juejin.im/user/5bbb7e966fb9a05d0d288910)

    前端工程师 @ 博客地址：http://119.27.166.247

    这么给你说吧，这里的布尔值其实也转换成数字了两个true就相当于两个1，1也也可以表示true，不信的话你可以这样试试Boolean（1）返回的也是true

    17天前

  - 

    [二道思无邪](https://juejin.im/user/5acee71e5188255cb07d7e5b)

    fe @ 百度

    我觉得是先转原始类型的那个逻辑，先调valueOf(),返回1。 虽然true本身是原始类型，但是无法计算吧，这个我也不是很清晰

    12天前

  - 

    [二道思无邪](https://juejin.im/user/5acee71e5188255cb07d7e5b)

    fe @ 百度

    回复[二道思无邪](https://juejin.im/user/5acee71e5188255cb07d7e5b)：我说的不对。。。普通类型要而且两个都不是字符串要先转数字

    12天前

  - 1
  - 2
  - 下一页

  评论

- 

  [RedJam](https://juejin.im/user/57700a730a2b58006a1e604b)



  class是Es6中的，Es5中组合设计模式的一个语法糖

  1评论23天前

- 

  [渔夫小新](https://juejin.im/user/59f167e7f265da430d573cb9)

  前端攻城狮

  几个总结的特点都很到位呢

  0评论23天前

- 

  [amy爱学习](https://juejin.im/user/5c23281a518825697324593d)



  class PrimitiveString {   static [Symbol.hasInstance](x) {     return typeof x === 'string'   } } 不懂这段代码，谁能讲下相关知识点？

  收起评论



  24天前

  - 

    [李雨冰](https://juejin.im/user/598cfa26f265da3e0e1065e4)

    前端 @ MYCOMPANY

    这是es6的知识，定义了一个类，然后重写了类的instanceof方法

    23天前

  - 

    [dsying](https://juejin.im/user/5b0e60f6f265da08f0339162)

    web @ 个体

    static 标记静态属性，通过 类.属性名 的方式调用

    23天前

  - 

    [闹闹不爱闹](https://juejin.im/user/59ba13fb5188256bd733c149)



    这段代码如果拿es5，静态属性怎么表达呢

    22天前

  - 

    [dsying](https://juejin.im/user/5b0e60f6f265da08f0339162)

    web @ 个体

    回复[闹闹不爱闹](https://juejin.im/user/59ba13fb5188256bd733c149)：const PrimitiveString = {} PrimitiveString[Symbol.hasInstance] = function(x) {     return typeof x === 'string' }

    22天前

  - 

    [Alian666](https://juejin.im/user/5c221220e51d4574572908a0)



    回复[dsying](https://juejin.im/user/5b0e60f6f265da08f0339162)：假如较真一点，const也是es6的内容，如果用es5的方式，是不是还要做什么处理？

    17天前

  - 1
  - 2
  - 下一页

  评论

- 

  [wxy同志](https://juejin.im/user/5ae43778f265da0b9671fbd1)



  看起来不错呢

  0评论25天前

- 

  [dsying](https://juejin.im/user/5b0e60f6f265da08f0339162)

  web @ 个体

  \``` function foo() {   console.log(this.a) } let a = 1 foo() ``` 大佬 你这个例子 在这里 应该不符合你的意思， let 不会 绑定到window上 ，所以 this.a 是undefined

  收起评论



  25天前

  - 

    [958](https://juejin.im/user/5c238c36e51d45463769b2fe)



    你的a是不是没有传参进函数

    24天前

  - 

    [dsying](https://juejin.im/user/5b0e60f6f265da08f0339162)

    web @ 个体

    通过this读取window上的变量a，和传参有什么关系

    23天前

  - 

    [哎呦歪](https://juejin.im/user/5af857126fb9a07ac90d4dd6)

    web前端开发

    let 声明的变量不会挂在window上，var声明的会

    23天前

  - 

    [86driver](https://juejin.im/user/5be6ff3e51882516cd708de4)



    大佬好眼力

    22天前

  - 

    [raintao](https://juejin.im/user/59de0ac151882578b8184826)

    web

    let 声明的变量不会挂在window上，结果应该是undefined

    18天前

  - 1
  - 2
  - 下一页

  评论

- 

  [徐小响](https://juejin.im/user/58758be7128fe1006b4840e8)

  前端开发 @ 观脉通讯

  看<你不知道的JavaScript>上中下，不就行了。

  收起评论



  25天前

  - 

    [呵呵就是我](https://juejin.im/user/5c2db9b06fb9a049dc025db2)



    是需要和你争辩下小册与书籍的概念益处的不同吗？？

    16天前

  - 

    [法令男](https://juejin.im/user/5a9101d65188257a690f82c4)



    这个小册好在节省你搜寻信息的成本，其实各有好处，两种学习方式并不冲突。光看书但是不成体系也不好。

    3天前

  评论

- 

  [吴楠](https://juejin.im/user/57b000947db2a2005421b5c5)



  对象类型的内存指向时候，可以顺带介绍下指针、值和堆内存、栈内存的关系

  6评论25天前

- 

  [Gray Coder](https://juejin.im/user/596430cb5188250d7d12cfd6)

  web前端工程师 @ 保密

  求速度更新啊，大厂面试没几天了？

  0评论25天前

- 

  [g1f9](https://juejin.im/user/5b85f0a06fb9a019fc76ed25)



  关于this的解释，我觉得还不够全面，this还有其他坑，我觉得可以看看这位大佬的解释 [https://github.com/mqyqingfeng/Blog/issues/7](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F7)

  0评论26天前

- 

  [徐Sir_](https://juejin.im/user/5a27897bf265da431523c7e1)

  终身学习者

  哈哈，又想到个小知识：严格模式下，this 默认为 undefined（非window）  function fn2(){   "use strict";   return this; }  fn2() === undefined; // true

  2评论26天前

- 

  [徐Sir_](https://juejin.im/user/5a27897bf265da431523c7e1)

  终身学习者

  关于箭头函数的 this 再补充一个小知识：因为箭头函数没有 this，所以也就不能用作构造函数。

  收起评论



  26天前

  - 

    [yck](https://juejin.im/user/574f8d8d2e958a005fd4edac)

    前端开发 @ 宋小菜

    老哥真稳

    26天前

  - 

    [太微天帝](https://juejin.im/user/5bbb7e966fb9a05d0d288910)

    前端工程师 @ 博客地址：http://119.27.166.247

    剪头函数中的确没有this，所以也不能用new关键字

    16天前

  - 

    [冯冯墨墨](https://juejin.im/user/57b501897db2a20054702769)

    web

    箭头函数已经自动绑定了bind, 不需要在构造函数中 额外的进行绑定

    4天前

  评论

- 

  [徐Sir_](https://juejin.im/user/5a27897bf265da431523c7e1)

  终身学习者

  请问下，这个结果这么理解呢，谢谢！ {name:1}+''+1 // 1 <-- Number类型 1

  收起评论



  26天前

  - 

    [一波万波](https://juejin.im/user/584cdf9c0ce463005c5aaf1d)



    同问

    26天前

  - 

    [不精通js不找对象](https://juejin.im/user/5b38911ee51d4558d8433f25)

    广东东软学院

    +1

    25天前

  - 

    [杨鑫丶](https://juejin.im/user/58b096f1128fe1006cbcbf77)

    Android攻城狮，前端爱好者

    如果{}被放在运算的最前面一位，他就会被当作代码块来处理，不论里面有什么，都不会影响计算结果，而 +'' 的结果是0，所以整体计算结果为 1，如果{}被放在运算中，那么他首先会调用toString方法，得出的结果是[object Object]

    25天前

  - 

    [一米八的萝卜](https://juejin.im/user/5a70824b518825733201eabb)

    fe

    前面的花括号是块作用域 相当于 +'' + 1 === 0 + 1

    25天前

  - 

    [若川](https://juejin.im/user/57974dc55bbb500063f522fd)

    freeCodeCamp杭州社区组织者之一

    前面已经有很好的回答了。 提一个经常用来对比的例子：` {} + [] `和 `[] + {}` 前者结果是代码块{}（代码块结尾不需要分号）+[]，也就是数组调用ToNumber()，所以结果是数字0。[ES5规范 类型转换 ToNumber](http://yanhaijing.com/es5/#106) 后者结果是[]数组转换成字符串''+对象转换成字符串`[object Object]` 所以结果是'[object Object]'。[ES5规范 ToString](http://yanhaijing.com/es5/#111) 更多强制类型转换可以看ES5规范和《不知道的JavaScript 中卷》第一部分第…展开全部

    25天前

  评论

- 

  [徐Sir_](https://juejin.im/user/5a27897bf265da431523c7e1)

  终身学习者

  大佬，这个说法会不会有误解呢『运算中其中一方为字符串，那么就会把另一方也转换为字符串』 比如：1+2+4+'1' ; // "71"

  收起评论



  26天前

  - 

    [徐Sir_](https://juejin.im/user/5a27897bf265da431523c7e1)

    终身学习者

    是否应该是将第一个字符串之后的转为字符串呢？ 比如：1+3+''+1+3；// "413"

    26天前

  - 

    [杨鑫丶](https://juejin.im/user/58b096f1128fe1006cbcbf77)

    Android攻城狮，前端爱好者

    算式是从左往右来计算的，也就是说 4 + '' 已经是字符串了，所以 '4' + 1 的 1 同样会被转换为字符串，同理 '41' + 3 的 3 也是一样，所以作者的话很好理解

    25天前

  - 

    [Better宫](https://juejin.im/user/5c24cd9fe51d450d5a01c010)



    徐Sir 牛B 

    23天前

  评论

- 

  [前端指南小组](https://juejin.im/user/5a33848a6fb9a0450a676740)

  前端 @ FEGuide

  已阅，甚好

  0评论1月前

- 

  [juejin_zsn](https://juejin.im/user/5a41fbb06fb9a0452a3c9497)

  前端小白白

  如果app可以提供笔记，记录知识点就更好了

  3评论1月前

- 

  [winty](https://juejin.im/user/5874526761ff4b006d4fd9a4)

  前端开发工程师

  const p1 = {   name: 'yck',   age: 25 } const定义的变量不能再被改变，这样写会报错

  收起评论



  1月前

  - 

    [yck](https://juejin.im/user/574f8d8d2e958a005fd4edac)

    前端开发 @ 宋小菜

    不知你是不是指的「对象（Object）类型」小节中的代码，如果是的话，你可以试下可不可以

    1月前

  - 

    [tengyu同志](https://juejin.im/user/5c20b397e51d453c0955a51f)



    不会保错，因为p1存储的是指针，示例代码没有改变p1的指针，而是指针指向的值，因此不会违反const定义

    26天前

  - 

    [名扬](https://juejin.im/user/5993915df265da24975fcb21)

    H5开发

    对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。

    26天前

  - 

    [winty](https://juejin.im/user/5874526761ff4b006d4fd9a4)

    前端开发工程师

    会啊，const p2 = test(p1),p1是对象，作为test的参数，则person和p1指向地址一致，person.age = 26。这就是试图改变p1啊。亲测报错了

    26天前

  - 

    [QianBaiDuHai](https://juejin.im/user/5b63b4acf265da0f9d1a1e1e)

    前端开发

    回复[winty](https://juejin.im/user/5874526761ff4b006d4fd9a4)：不会报错啊，我刚测试了，上面说的挺对的，像数组，对象这种引用的修改下标是不会发生报错的

    26天前

  - 1
  - 2
  - 下一页

  评论

- 

  [∝俊。](https://juejin.im/user/59a358c0518825242c4227cf)

  前端切图仔

  这个this讲得很好很清晰

  0评论1月前

- 

  [Self-Growth](https://juejin.im/user/5be965b6e51d450d050230d5)



  关于箭头函数的this的说法太绝对了，当包裹剪头函数的外层普通函数的this指向发生变化时，相当于变更了箭头函数的this指向

  收起评论



  1月前

  - 

    [yck](https://juejin.im/user/574f8d8d2e958a005fd4edac)

    前端开发 @ 宋小菜

    「箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this」，普通函数 this 变了，当然改了箭头函数的 this 了

    1月前

  评论

- 

  [枝枝君](https://juejin.im/user/5c06402751882550d05cc142)



  this流程图 很棒

  0评论1月前

- 

  [西风瘦码](https://juejin.im/user/584955940ce463005c481f60)

  前端 @ 杭州

  这是我见过对this最简洁的解释，回想看过的文章中的解释，好像无外乎就是这几种情况，关键是识别遇到是那种情况…

  0评论1月前

- 

  [LienJack](https://juejin.im/user/5aeda6d5518825670c45d147)

  前端打字员

  一张图就能说明this，厉害了

  0评论1月前

- 

  [LI同学](https://juejin.im/user/59c602276fb9a00a600f7575)



  但是当我们重新为了 person 分配了一个对象时。为什么不会改变address#001的值，而是创建一个address#002。

  收起评论



  1月前

  - 

    [yck](https://juejin.im/user/574f8d8d2e958a005fd4edac)

    前端开发 @ 宋小菜

    {} 等于 new Object()，我既然创建了一个新的对象，当然是新的地址了

    1月前

  - 

    [puranzhang](https://juejin.im/user/5c2315f46fb9a049c15f40f8)



    因为你并没有直接去 address#001 上把原先的 value (原来的对象) 替换成 new Object()，而是把这个新对象的地址 assign 给了 person。所以 p1 会持有原来的对象地址 address#001，person 会持有新的对象的地址 address#002。

    25天前

  评论

- 

  [墨言君](https://juejin.im/user/5b8df5cf51882543057da9f6)



  终于搞清楚了几种常见的基本类型转换，还有this解析，简洁清晰！特好！

  0评论1月前

- 

  [naice](https://juejin.im/user/5768b5f8a341310064ef444e)

  入门级前端开发 @ iiiiiiing

  突发奇想试了一下,  var a = {cc: 1};  a.toString() 得到"[object Object]" 但是{cc: 1}.toString() 就直接报错了，不知道 {} 是不是被认为块级原因？？？

  收起评论



  1月前

  - 

    [yck](https://juejin.im/user/574f8d8d2e958a005fd4edac)

    前端开发 @ 宋小菜

    对的

    1月前

  - 

    [我依旧已久](https://juejin.im/user/5b9c66575188255c8c0c886b)



    你这个{cc: 1} 都没声明怎么可能不报错

    25天前

  - 

    [Only不想说话](https://juejin.im/user/5c231cb7e51d45673971b868)



    toString 是Object底层专用

    25天前

  - 

    [cheche062](https://juejin.im/user/593f3b2dac502e006b553f4b)

    web前端

    ({cc: 1}).toString()  or  ({cc: 1}.toString())

    25天前

  评论

- 

  [森小白](https://juejin.im/user/58cab8d244d90400682c39f3)



  this很棒

  1评论1月前